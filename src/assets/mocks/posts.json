{
    "posts": [
      {
        "id": 1,
        "title": {
          "pt-BR": "O 'S' de Single Responsibility Principle (SRP)",
          "en-US": "The 'S' in Single Responsibility Principle (SRP)"
        },
        "content": {
          "pt-BR": "VocÃª jÃ¡ se deparou com um cÃ³digo que parecia fazer de tudo um pouco e era difÃ­cil de manter? Isso acontece porque ele provavelmente nÃ£o seguia o princÃ­pio de responsabilidade Ãºnica, o SRP.",
          "en-US": "Have you ever encountered code that seemed to do a bit of everything and was hard to maintain? This happens because it probably didn't follow the Single Responsibility Principle, SRP."
        },
        "date": "2024-06-23",
        "image": "../assets/Solid.jpg"
      },
      {
        "id": 2,
        "title": {
          "pt-BR": "Os 3 ciclos de vida da injeÃ§Ã£o de dependÃªncia no .NET",
          "en-US": "The 3 lifetimes of dependency injection in .NET"
        },
        "content": {
          "pt-BR": "ğŸš¨ TÃ³pico bastante perguntado em entrevistas de desenvolvedor .NET\n\nQuais sÃ£o os 3 ciclos de vida da injeÃ§Ã£o de dependÃªncia no ambiente do .NET? Vamos explicar cada um:\n\n1) **Transient**: A injeÃ§Ã£o de dependÃªncia no escopo funciona cada vez que um serviÃ§o Ã© solicitado, o contÃªiner de DI cria uma nova instÃ¢ncia. Isso Ã© ideal para serviÃ§os temporÃ¡rios, como validadores de formulÃ¡rios ou caches de dados temporÃ¡rios. No entanto, lembre-se de que essas instÃ¢ncias nÃ£o sÃ£o compartilhadas e podem ser descartadas apÃ³s o uso.\n\n2) **Scoped**: Uma instÃ¢ncia do serviÃ§o Ã© criada por solicitaÃ§Ã£o HTTP e compartilhada durante toda a vida da solicitaÃ§Ã£o. Isso Ã© Ãºtil para serviÃ§os que precisam manter estado entre vÃ¡rias operaÃ§Ãµes dentro da mesma solicitaÃ§Ã£o, como serviÃ§os de banco de dados ou caches de sessÃ£o.\n\n3) **Singleton**: Uma Ãºnica instÃ¢ncia do serviÃ§o Ã© criada e reutilizada em todo o aplicativo. Isso Ã© adequado para serviÃ§os globais, como configuraÃ§Ãµes de aplicativo, serviÃ§os de log ou conexÃµes de banco de dados. No entanto, tome cuidado com o estado compartilhado, pois ele pode afetar a concorrÃªncia e a seguranÃ§a.",
          "en-US": "ğŸš¨ A highly asked topic in .NET developer interviews\n\nWhat are the 3 lifetimes of dependency injection in the .NET environment? Let's explain each one:\n\n1) **Transient**: The dependency injection works every time a service is requested, and the DI container creates a new instance. This is ideal for temporary services like form validators or temporary data caches. However, remember that these instances are not shared and can be discarded after use.\n\n2) **Scoped**: A service instance is created per HTTP request and shared throughout the lifetime of the request. This is useful for services that need to maintain state across multiple operations within the same request, like database services or session caches.\n\n3) **Singleton**: A single service instance is created and reused throughout the application. This is suitable for global services like application settings, logging services, or database connections. However, be cautious with shared state, as it might affect concurrency and security."
        },
        "date": "2024-07-06",
        "image": "../assets/dependency_injection.jpg"
      },
      {
        "id": 3,
        "title": {
          "pt-BR": "Classe Abstrata vs Interface: Entendendo as diferenÃ§as!",
          "en-US": "Abstract Class vs Interface: Understanding the Differences!"
        },
        "content": {
          "pt-BR": "ğŸš¨ Conceito fundamental da POO que vocÃª deve ter na ponta na lÃ­ngua!\n\n**Classe Abstrata vs Interface: Entendendo as diferenÃ§as!**\n\nğŸ’¡ **Classe Abstrata**:\n\nÃ‰ como um modelo parcialmente construÃ­do. VocÃª pode ter mÃ©todos com implementaÃ§Ã£o e mÃ©todos abstratos que precisam ser definidos nas subclasses.\n\nUse quando vocÃª quer compartilhar cÃ³digo comum entre vÃ¡rias classes, mas ainda assim permitir que cada uma tenha sua prÃ³pria implementaÃ§Ã£o.\n\nâœ¨ **Interface**:\n\nImagine uma interface como um contrato. Ela especifica mÃ©todos que devem ser implementados, mas nÃ£o fornece nenhuma implementaÃ§Ã£o.\n\nPerfeita para definir capacidades que classes diferentes devem ter, sem impor uma hierarquia.\n\nğŸ”§ **Quando usar cada uma?**\n\nUse classe abstrata quando hÃ¡ uma base comum de comportamento, mas vocÃª precisa de personalizaÃ§Ãµes nas subclasses.\n\nUse interface quando diferentes classes precisam cumprir um contrato especÃ­fico sem herdar um comportamento comum.\n\nğŸ”— **Exemplo PrÃ¡tico**:\n\nPense em uma classe abstrata como um plano de construÃ§Ã£o de um carro. Ela define que todo carro deve ter rodas e motor, mas deixa cada fabricante decidir os detalhes.\n\nJÃ¡ uma interface Ã© como uma especificaÃ§Ã£o de seguranÃ§a de carros ğŸ“‹. Todos os carros precisam cumprir essas especificaÃ§Ãµes, mas isso nÃ£o dita como os carros sÃ£o construÃ­dos internamente.\n\nE vocÃª, como tem utilizado classes abstratas e interfaces no seu cÃ³digo?",
          "en-US": "ğŸš¨ A fundamental OOP concept you should have at the tip of your tongue!\n\n**Abstract Class vs Interface: Understanding the Differences!**\n\nğŸ’¡ **Abstract Class**:\n\nIt's like a partially built blueprint. You can have methods with implementations and abstract methods that must be defined in subclasses.\n\nUse it when you want to share common code across multiple classes but still allow each one to have its own implementation.\n\nâœ¨ **Interface**:\n\nImagine an interface as a contract. It specifies methods that must be implemented, but does not provide any implementation.\n\nPerfect for defining capabilities that different classes must have without enforcing a hierarchy.\n\nğŸ”§ **When to use each one?**\n\nUse an abstract class when there's a common base behavior, but you need customizations in the subclasses.\n\nUse an interface when different classes need to fulfill a specific contract without inheriting common behavior.\n\nğŸ”— **Practical Example**:\n\nThink of an abstract class as a car construction blueprint. It defines that every car should have wheels and an engine, but leaves each manufacturer to decide the details.\n\nAn interface is like a car safety specification ğŸ“‹. All cars must comply with these specifications, but it doesn't dictate how the cars are built internally.\n\nAnd you, how have you been using abstract classes and interfaces in your code?"
        },
        "date": "2023-11-05",
        "image": "../assets/abstract_class_x_interface.jpg"
      },
      {
        "id": 4,
        "title": {
          "pt-BR": "O que Ã© o OCP? PrincÃ­pio de Aberto/Fechado",
          "en-US": "What is OCP? Open/Closed Principle"
        },
        "content": {
          "pt-BR": "ğŸ§© O que Ã© o OCP? O PrincÃ­pio de Aberto/Fechado afirma que uma classe deve ser aberta para extensÃ£o, mas fechada para modificaÃ§Ã£o. Em outras palavras, devemos ser capazes de adicionar novas funcionalidades a uma classe sem alterar seu cÃ³digo existente.\n\nğŸ’¡ Por que isso Ã© importante? Manter o cÃ³digo fechado para modificaÃ§Ã£o reduz o risco de introduzir novos bugs em partes jÃ¡ testadas e estÃ¡veis. Ao mesmo tempo, permitir a extensÃ£o atravÃ©s de novas funcionalidades facilita a evoluÃ§Ã£o do software, tornando-o mais adaptÃ¡vel a mudanÃ§as e novas necessidades.\n\nğŸ”¨ Como aplicar o OCP na prÃ¡tica?\n\n- Uso de Interfaces e AbstraÃ§Ãµes: Utilize interfaces e classes abstratas para definir comportamentos que podem ser estendidos.\n- HeranÃ§a e Polimorfismo: Crie novas classes que herdam de classes base e sobrescrevem mÃ©todos para adicionar ou modificar comportamentos.\n- Design Patterns: PadrÃµes de projeto como Strategy, Decorator e Factory sÃ£o excelentes ferramentas para seguir o OCP.\n\nğŸ‘· Exemplo:\nImagine que vocÃª tem uma classe CalculadoraSalario que calcula o salÃ¡rio de funcionÃ¡rios. Inicialmente, ela sÃ³ lida com funcionÃ¡rios de tempo integral. Agora, vocÃª precisa adicionar o cÃ¡lculo para funcionÃ¡rios freelancers. Seguindo o OCP, vocÃª criaria uma interface ICalculadoraSalario e implementaria duas classes: CalculadoraSalarioTempoIntegral e CalculadoraSalarioFreelancer, cada uma com sua lÃ³gica especÃ­fica.",
          "en-US": "ğŸ§© What is OCP? The Open/Closed Principle states that a class should be open for extension but closed for modification. In other words, we should be able to add new functionalities to a class without changing its existing code.\n\nğŸ’¡ Why is this important? Keeping code closed for modification reduces the risk of introducing new bugs into already tested and stable parts. At the same time, allowing extension through new functionalities makes the software more adaptable to changes and new requirements.\n\nğŸ”¨ How to apply OCP in practice?\n\n- Use of Interfaces and Abstractions: Use interfaces and abstract classes to define behaviors that can be extended.\n- Inheritance and Polymorphism: Create new classes that inherit from base classes and override methods to add or modify behaviors.\n- Design Patterns: Patterns like Strategy, Decorator, and Factory are excellent tools for following OCP.\n\nğŸ‘· Example:\nImagine you have a SalaryCalculator class that calculates employee salaries. Initially, it only handles full-time employees. Now, you need to add calculations for freelancers. Following OCP, you would create an ISalaryCalculator interface and implement two classes: FullTimeSalaryCalculator and FreelancerSalaryCalculator, each with its specific logic."
        },
        "date": "2024-10-27",
        "image": "../assets/Solid2.jpg"
      },
      {
        "id": 5,
        "title": {
          "pt-BR": "O mÃ­nimo sobre cache que vocÃª deveria saber",
          "en-US": "The Minimum You Should Know About Cache"
        },
        "content": {
          "pt-BR": "ğŸ’¡ ğŸ’­ O mÃ­nimo sobre cache que vocÃª deveria saber!\n\nO cache Ã© como uma memÃ³ria especial para o seu aplicativo. Ele armazena dados frequentemente usados, tornando o acesso mais rÃ¡pido e eficiente. No mundo do .NET, temos duas formas principais de usar o cache: na memÃ³ria e distribuÃ­do.\n\nCache na MemÃ³ria ğŸ§ \n\nVantagens:\n- Simplicidade: Implementar o cache na memÃ³ria Ã© fÃ¡cil e rÃ¡pido.\n- Velocidade: Os dados ficam Ã  mÃ£o, prontos para uso.\n- Controle: VocÃª pode definir quando os dados expiram e quais sÃ£o as prioridades.\n\nDesvantagens:\n- Limitado a um Ãšnico Servidor: O cache na memÃ³ria funciona bem para aplicativos em um Ãºnico servidor, mas nÃ£o compartilha dados entre servidores.\n- Consumo de MemÃ³ria: Os dados em cache ocupam espaÃ§o na memÃ³ria do aplicativo.\n\nCache DistribuÃ­do ğŸŒ\n\nVantagens:\n- Escalabilidade: Compartilha dados em cache entre vÃ¡rias instÃ¢ncias de aplicativos ou servidores.\n- RedundÃ¢ncia: Mesmo se um servidor falhar, os dados em cache permanecem disponÃ­veis.\n- Flexibilidade: VocÃª pode usar serviÃ§os como Redis ou SQL Server para armazenar dados em cache.\n\nDesvantagens:\n- Complexidade: Configurar e gerenciar um cache distribuÃ­do pode ser mais complicado.\n- LatÃªncia: O acesso aos dados em cache pode ser um pouco mais lento do que na memÃ³ria local.\n\nEm resumo, escolha a estratÃ©gia de cache que melhor se adapta Ã s necessidades do seu aplicativo. O importante Ã© disponibilizar o mÃ¡ximo de performance para o usuÃ¡rio. ğŸ˜‰ğŸš€",
          "en-US": "ğŸ’¡ ğŸ’­ The Minimum You Should Know About Cache!\n\nCache is like a special memory for your application. It stores frequently used data, making access faster and more efficient. In the .NET world, we have two main ways to use cache: in-memory and distributed.\n\nIn-Memory Cache ğŸ§ \n\nAdvantages:\n- Simplicity: Implementing in-memory cache is easy and quick.\n- Speed: Data is readily available for use.\n- Control: You can define when data expires and what the priorities are.\n\nDisadvantages:\n- Limited to a Single Server: In-memory cache works well for applications on a single server but does not share data between servers.\n- Memory Consumption: Cached data occupies space in the application's memory.\n\nDistributed Cache ğŸŒ\n\nAdvantages:\n- Scalability: Shares cached data across multiple application instances or servers.\n- Redundancy: Even if one server fails, the cached data remains available.\n- Flexibility: You can use services like Redis or SQL Server to store cached data.\n\nDisadvantages:\n- Complexity: Setting up and managing a distributed cache can be more complicated.\n- Latency: Access to cached data can be slightly slower than local memory.\n\nIn summary, choose the caching strategy that best fits your application's needs. The important thing is to provide maximum performance for the user. ğŸ˜‰ğŸš€"
        },
        "date": "2024-03-15",
        "image": "../assets/cache.jpg"
      }
    ]
  }