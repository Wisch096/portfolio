{
    "posts": [
      {
        "id": 1,
        "title": {
          "pt-BR": "O 'S' de Single Responsibility Principle (SRP)",
          "en-US": "The 'S' in Single Responsibility Principle (SRP)"
        },
        "content": {
          "pt-BR": "Voc√™ j√° se deparou com um c√≥digo que parecia fazer de tudo um pouco e era dif√≠cil de manter? Isso acontece porque ele provavelmente n√£o seguia o princ√≠pio de responsabilidade √∫nica, o SRP.",
          "en-US": "Have you ever encountered code that seemed to do a bit of everything and was hard to maintain? This happens because it probably didn't follow the Single Responsibility Principle, SRP."
        },
        "date": "2024-06-23",
        "image": "../assets/Solid.jpg"
      },
      {
        "id": 2,
        "title": {
          "pt-BR": "Os 3 ciclos de vida da inje√ß√£o de depend√™ncia no .NET",
          "en-US": "The 3 lifetimes of dependency injection in .NET"
        },
        "content": {
          "pt-BR": "üö® T√≥pico bastante perguntado em entrevistas de desenvolvedor .NET\n\nQuais s√£o os 3 ciclos de vida da inje√ß√£o de depend√™ncia no ambiente do .NET? Vamos explicar cada um:\n\n1) **Transient**: A inje√ß√£o de depend√™ncia no escopo funciona cada vez que um servi√ßo √© solicitado, o cont√™iner de DI cria uma nova inst√¢ncia. Isso √© ideal para servi√ßos tempor√°rios, como validadores de formul√°rios ou caches de dados tempor√°rios. No entanto, lembre-se de que essas inst√¢ncias n√£o s√£o compartilhadas e podem ser descartadas ap√≥s o uso.\n\n2) **Scoped**: Uma inst√¢ncia do servi√ßo √© criada por solicita√ß√£o HTTP e compartilhada durante toda a vida da solicita√ß√£o. Isso √© √∫til para servi√ßos que precisam manter estado entre v√°rias opera√ß√µes dentro da mesma solicita√ß√£o, como servi√ßos de banco de dados ou caches de sess√£o.\n\n3) **Singleton**: Uma √∫nica inst√¢ncia do servi√ßo √© criada e reutilizada em todo o aplicativo. Isso √© adequado para servi√ßos globais, como configura√ß√µes de aplicativo, servi√ßos de log ou conex√µes de banco de dados. No entanto, tome cuidado com o estado compartilhado, pois ele pode afetar a concorr√™ncia e a seguran√ßa.",
          "en-US": "üö® A highly asked topic in .NET developer interviews\n\nWhat are the 3 lifetimes of dependency injection in the .NET environment? Let's explain each one:\n\n1) **Transient**: The dependency injection works every time a service is requested, and the DI container creates a new instance. This is ideal for temporary services like form validators or temporary data caches. However, remember that these instances are not shared and can be discarded after use.\n\n2) **Scoped**: A service instance is created per HTTP request and shared throughout the lifetime of the request. This is useful for services that need to maintain state across multiple operations within the same request, like database services or session caches.\n\n3) **Singleton**: A single service instance is created and reused throughout the application. This is suitable for global services like application settings, logging services, or database connections. However, be cautious with shared state, as it might affect concurrency and security."
        },
        "date": "2024-07-06",
        "image": "../assets/dependency_injection.jpg"
      },
      {
        "id": 3,
        "title": {
          "pt-BR": "Classe Abstrata vs Interface: Entendendo as diferen√ßas!",
          "en-US": "Abstract Class vs Interface: Understanding the Differences!"
        },
        "content": {
          "pt-BR": "üö® Conceito fundamental da POO que voc√™ deve ter na ponta na l√≠ngua!\n\n**Classe Abstrata vs Interface: Entendendo as diferen√ßas!**\n\nüí° **Classe Abstrata**:\n\n√â como um modelo parcialmente constru√≠do. Voc√™ pode ter m√©todos com implementa√ß√£o e m√©todos abstratos que precisam ser definidos nas subclasses.\n\nUse quando voc√™ quer compartilhar c√≥digo comum entre v√°rias classes, mas ainda assim permitir que cada uma tenha sua pr√≥pria implementa√ß√£o.\n\n‚ú® **Interface**:\n\nImagine uma interface como um contrato. Ela especifica m√©todos que devem ser implementados, mas n√£o fornece nenhuma implementa√ß√£o.\n\nPerfeita para definir capacidades que classes diferentes devem ter, sem impor uma hierarquia.\n\nüîß **Quando usar cada uma?**\n\nUse classe abstrata quando h√° uma base comum de comportamento, mas voc√™ precisa de personaliza√ß√µes nas subclasses.\n\nUse interface quando diferentes classes precisam cumprir um contrato espec√≠fico sem herdar um comportamento comum.\n\nüîó **Exemplo Pr√°tico**:\n\nPense em uma classe abstrata como um plano de constru√ß√£o de um carro. Ela define que todo carro deve ter rodas e motor, mas deixa cada fabricante decidir os detalhes.\n\nJ√° uma interface √© como uma especifica√ß√£o de seguran√ßa de carros üìã. Todos os carros precisam cumprir essas especifica√ß√µes, mas isso n√£o dita como os carros s√£o constru√≠dos internamente.\n\nE voc√™, como tem utilizado classes abstratas e interfaces no seu c√≥digo?",
          "en-US": "üö® A fundamental OOP concept you should have at the tip of your tongue!\n\n**Abstract Class vs Interface: Understanding the Differences!**\n\nüí° **Abstract Class**:\n\nIt's like a partially built blueprint. You can have methods with implementations and abstract methods that must be defined in subclasses.\n\nUse it when you want to share common code across multiple classes but still allow each one to have its own implementation.\n\n‚ú® **Interface**:\n\nImagine an interface as a contract. It specifies methods that must be implemented, but does not provide any implementation.\n\nPerfect for defining capabilities that different classes must have without enforcing a hierarchy.\n\nüîß **When to use each one?**\n\nUse an abstract class when there's a common base behavior, but you need customizations in the subclasses.\n\nUse an interface when different classes need to fulfill a specific contract without inheriting common behavior.\n\nüîó **Practical Example**:\n\nThink of an abstract class as a car construction blueprint. It defines that every car should have wheels and an engine, but leaves each manufacturer to decide the details.\n\nAn interface is like a car safety specification üìã. All cars must comply with these specifications, but it doesn't dictate how the cars are built internally.\n\nAnd you, how have you been using abstract classes and interfaces in your code?"
        },
        "date": "2023-11-05",
        "image": "../assets/abstract_class_x_interface.jpg"
      },
      {
        "id": 4,
        "title": {
          "pt-BR": "O que √© o OCP? Princ√≠pio de Aberto/Fechado",
          "en-US": "What is OCP? Open/Closed Principle"
        },
        "content": {
          "pt-BR": "üß© O que √© o OCP? O Princ√≠pio de Aberto/Fechado afirma que uma classe deve ser aberta para extens√£o, mas fechada para modifica√ß√£o. Em outras palavras, devemos ser capazes de adicionar novas funcionalidades a uma classe sem alterar seu c√≥digo existente.\n\nüí° Por que isso √© importante? Manter o c√≥digo fechado para modifica√ß√£o reduz o risco de introduzir novos bugs em partes j√° testadas e est√°veis. Ao mesmo tempo, permitir a extens√£o atrav√©s de novas funcionalidades facilita a evolu√ß√£o do software, tornando-o mais adapt√°vel a mudan√ßas e novas necessidades.\n\nüî® Como aplicar o OCP na pr√°tica?\n\n- Uso de Interfaces e Abstra√ß√µes: Utilize interfaces e classes abstratas para definir comportamentos que podem ser estendidos.\n- Heran√ßa e Polimorfismo: Crie novas classes que herdam de classes base e sobrescrevem m√©todos para adicionar ou modificar comportamentos.\n- Design Patterns: Padr√µes de projeto como Strategy, Decorator e Factory s√£o excelentes ferramentas para seguir o OCP.\n\nüë∑ Exemplo:\nImagine que voc√™ tem uma classe CalculadoraSalario que calcula o sal√°rio de funcion√°rios. Inicialmente, ela s√≥ lida com funcion√°rios de tempo integral. Agora, voc√™ precisa adicionar o c√°lculo para funcion√°rios freelancers. Seguindo o OCP, voc√™ criaria uma interface ICalculadoraSalario e implementaria duas classes: CalculadoraSalarioTempoIntegral e CalculadoraSalarioFreelancer, cada uma com sua l√≥gica espec√≠fica.",
          "en-US": "üß© What is OCP? The Open/Closed Principle states that a class should be open for extension but closed for modification. In other words, we should be able to add new functionalities to a class without changing its existing code.\n\nüí° Why is this important? Keeping code closed for modification reduces the risk of introducing new bugs into already tested and stable parts. At the same time, allowing extension through new functionalities makes the software more adaptable to changes and new requirements.\n\nüî® How to apply OCP in practice?\n\n- Use of Interfaces and Abstractions: Use interfaces and abstract classes to define behaviors that can be extended.\n- Inheritance and Polymorphism: Create new classes that inherit from base classes and override methods to add or modify behaviors.\n- Design Patterns: Patterns like Strategy, Decorator, and Factory are excellent tools for following OCP.\n\nüë∑ Example:\nImagine you have a SalaryCalculator class that calculates employee salaries. Initially, it only handles full-time employees. Now, you need to add calculations for freelancers. Following OCP, you would create an ISalaryCalculator interface and implement two classes: FullTimeSalaryCalculator and FreelancerSalaryCalculator, each with its specific logic."
        },
        "date": "2024-10-27",
        "image": "../assets/Solid2.jpg"
      },
      {
        "id": 5,
        "title": {
          "pt-BR": "O m√≠nimo sobre cache que voc√™ deveria saber",
          "en-US": "The Minimum You Should Know About Cache"
        },
        "content": {
          "pt-BR": "üí° üí≠ O m√≠nimo sobre cache que voc√™ deveria saber!\n\nO cache √© como uma mem√≥ria especial para o seu aplicativo. Ele armazena dados frequentemente usados, tornando o acesso mais r√°pido e eficiente. No mundo do .NET, temos duas formas principais de usar o cache: na mem√≥ria e distribu√≠do.\n\nCache na Mem√≥ria üß†\n\nVantagens:\n- Simplicidade: Implementar o cache na mem√≥ria √© f√°cil e r√°pido.\n- Velocidade: Os dados ficam √† m√£o, prontos para uso.\n- Controle: Voc√™ pode definir quando os dados expiram e quais s√£o as prioridades.\n\nDesvantagens:\n- Limitado a um √önico Servidor: O cache na mem√≥ria funciona bem para aplicativos em um √∫nico servidor, mas n√£o compartilha dados entre servidores.\n- Consumo de Mem√≥ria: Os dados em cache ocupam espa√ßo na mem√≥ria do aplicativo.\n\nCache Distribu√≠do üåê\n\nVantagens:\n- Escalabilidade: Compartilha dados em cache entre v√°rias inst√¢ncias de aplicativos ou servidores.\n- Redund√¢ncia: Mesmo se um servidor falhar, os dados em cache permanecem dispon√≠veis.\n- Flexibilidade: Voc√™ pode usar servi√ßos como Redis ou SQL Server para armazenar dados em cache.\n\nDesvantagens:\n- Complexidade: Configurar e gerenciar um cache distribu√≠do pode ser mais complicado.\n- Lat√™ncia: O acesso aos dados em cache pode ser um pouco mais lento do que na mem√≥ria local.\n\nEm resumo, escolha a estrat√©gia de cache que melhor se adapta √†s necessidades do seu aplicativo. O importante √© disponibilizar o m√°ximo de performance para o usu√°rio. üòâüöÄ",
          "en-US": "üí° üí≠ The Minimum You Should Know About Cache!\n\nCache is like a special memory for your application. It stores frequently used data, making access faster and more efficient. In the .NET world, we have two main ways to use cache: in-memory and distributed.\n\nIn-Memory Cache üß†\n\nAdvantages:\n- Simplicity: Implementing in-memory cache is easy and quick.\n- Speed: Data is readily available for use.\n- Control: You can define when data expires and what the priorities are.\n\nDisadvantages:\n- Limited to a Single Server: In-memory cache works well for applications on a single server but does not share data between servers.\n- Memory Consumption: Cached data occupies space in the application's memory.\n\nDistributed Cache üåê\n\nAdvantages:\n- Scalability: Shares cached data across multiple application instances or servers.\n- Redundancy: Even if one server fails, the cached data remains available.\n- Flexibility: You can use services like Redis or SQL Server to store cached data.\n\nDisadvantages:\n- Complexity: Setting up and managing a distributed cache can be more complicated.\n- Latency: Access to cached data can be slightly slower than local memory.\n\nIn summary, choose the caching strategy that best fits your application's needs. The important thing is to provide maximum performance for the user. üòâüöÄ"
        },
        "date": "2024-03-15",
        "image": "../assets/cache.jpg"
      }
    ]
  }